Here is my Arcanoid clone written in c++ using freeglut library.
```cpp
class ball :  public game_object {public:static std::set<ball*> balls;ball(v2 p) : game_object(p) {sticking = true;normal_speed = 4;shield = true;speed_changing_time = -100000;balls.insert(this);}virtual ~ball() {balls.erase(this);}static void initBonuses();static void makeShield();static void drawAllBalls();static void changeSpeed();static double normal_speed;virtual bool inGame() override;virtual void move() override;virtual v2 getSize() override;void stick();void notstick();bool isSticking() {return sticking;}void pushOff(game_object* v);private:void drawBall();static int speed_changing_time;static bool shield;bool sticking; };#define UNDEAD_THRESHOLD 5class block : public game_object {public:static std::set<block*> blocks;block(v2 p) : game_object(p), hp(create_random(UNDEAD_THRESHOLD) + 1) {blocks.insert(this);};void touch();int getHP() {return hp;}virtual bool inGame() override;static void setSize(v2 s);static void drawAllBlocks();virtual v2 getSize() override{return size;}virtual ~block() {blocks.erase(this);int chance = create_random(2);if (chance == 0) create_bonus();}private:int hp;static v2 size;void drawBlock();void create_bonus();};class bonus : public game_object {public:static std::set<bonus*> bonuses;bonus(v2 p) : game_object(p, { 0, -1.0 }) {bonuses.insert(this);}static void drawAllBonuses();virtual v2 getSize() override {return { radius * 2.0, radius * 2.0 };}virtual void activate() = 0;virtual bool inGame() override;virtual ~bonus() {bonuses.erase(this);}protected:virtual void drawBonus() = 0;};class change_paddle_size : public bonus {public:change_paddle_size(v2 p) :bonus(p) {};virtual void drawBonus() override;virtual void activate() override;};class change_ball_speed : public bonus {public:change_ball_speed(v2 p) : bonus(p) {};virtual void drawBonus() override;virtual void activate() override;};class add_ball : public bonus{public:add_ball(v2 p) :bonus(p) {};virtual void drawBonus() override;virtual void activate() override;};class make_shield :	public bonus {public:make_shield(v2 p) :bonus(p) {};virtual void drawBonus() override;virtual void activate() override;};class sticking : public bonus{public:sticking(v2 p) : bonus(p) {};virtual void drawBonus() override;virtual void activate() override;};class game{public:game() {block_size = { 50, 20 };game_object::setWindowSize(600, 600);// game_object::setDealay(50000);game_object::globalClockReset();game_object::setRadius(10);block::setSize(block_size);ball::initBonuses();ball* p = new ball({ 0, 0 });create_field();}void initGame(int argc, char** argv);void theLogic();static v2 touch(game_object* f, game_object* s);private:void initGlutFunctions();void create_field();v2 block_size;};typedef struct v2 {double x;double y;bool operator==(const v2 &other){return (x==other.x && y==other.y);}bool operator!=(const v2 &other){return (x!=other.x || y!=other.y);}} v2;class game_object {protected:v2 pos, speed;void drawPoly(int n);static int mainTime;// static int delay; static int radius; public:game_object() : pos({ 0, 0 }), speed({ 0, 0 }) {};game_object(v2 p) : pos(p), speed({ 0, 0 }) {};game_object(v2 p, v2 v) : pos(p), speed(v) {};virtual v2 getSize() = 0;virtual void move();virtual bool inGame() = 0;static void setWindowSize(int W, int H) {windowSize.x = W;windowSize.y = H;}void setSpeed(v2 s) {speed = s;}static void setRadius(int r) {radius = r;}v2 getPos() {return pos;}// static void setDealay(int d) {// 	delay = d;// }static void globalClockReset() {mainTime = 0;}static void globalClockTick() {mainTime++;}static v2 windowSize;static int create_random(int n);};class paddle : public game_object {public:static paddle* mainPaddle;paddle() :game_object({ 300, 100 }) {size = { 80, 10 };change_size_time = -100000;mainPaddle = this;to_stick = false;}void changeSize();void drawPaddle();void moveLeft();void moveRight();virtual void move() {}; void activateSticking();virtual v2 getSize();bool isReadyToStick() {return to_stick;}void notReadyToStick() {to_stick = false;}virtual bool inGame() {return true;}private:v2 size;int change_size_time;bool to_stick;};std::set<ball*> ball::balls;int ball::speed_changing_time;bool ball::shield;double ball::normal_speed;v2 emp = { -1, -1 };void ball::initBonuses() {speed_changing_time = INT_MIN;shield = false;}void ball::makeShield() {shield = true;}void ball::drawAllBalls() {for (auto u : balls) {glColor3f(1.0f, 1.0f, 1.0f);u->drawBall();}}void ball::drawBall() {drawPoly(30);if (shield) {glBegin(GL_QUADS);glColor3f(1.0f, 1.0f, 1.0f);glVertex2f(0, 0);glVertex2f(0, 10);glVertex2f(600, 10);glVertex2f(600, 0);glEnd();}}void ball::changeSpeed() {speed_changing_time = mainTime;}bool ball::inGame() {if (pos.y < 0) return false;return true;}void ball::move() {if (sticking) {v2 t = paddle::mainPaddle->getPos();v2 s = paddle::mainPaddle->getSize();pos.x = t.x;pos.y = t.y + s.y + radius;return;}if (pos.y + radius >= windowSize.y) {speed.y *= -1;}pos.x += speed.x;pos.y += speed.y;if (pos.x - radius <= 0 || pos.x + radius >= windowSize.x) {speed.x *= -1;}if (shield && pos.y - radius <= 0) {speed.y *= -1;shield = false;}}v2 ball::getSize() {return { radius * 2.0, radius * 2.0 };}void ball::stick() {sticking = true;}void ball::notstick() {sticking = false;}void ball::pushOff(game_object* v) {v2 t = game::touch(this, v);double rnd_offset = (game_object::create_random(3) - 1) * 0.01;if (t.x < t.y) {double alpha = (this->getPos().x - v->getPos().x) * 120 / v->getSize().x;double sy = normal_speed * cos(alpha) + rnd_offset;double sx = (-1) * normal_speed * sin(alpha) + rnd_offset;this->speed = { sx, sy };if (v == paddle::mainPaddle) {this->speed = { this->speed.x, -this->speed.y };}}else {double alpha = (this->getPos().y - v->getPos().y) * 120 / v->getSize().y;double sy = normal_speed * sin(alpha) + rnd_offset;double sx = (-1) * normal_speed * cos(alpha) + rnd_offset;this->speed = { sx, sy };if (v == paddle::mainPaddle) {this->speed = { -this->speed.x, this->speed.y };}}while (game::touch(this, v) != emp) {this->move();}}void add_ball::drawBonus() {drawPoly(3);}void add_ball::activate() {ball* p = new ball(pos);}std::set <block*> block::blocks;v2 block::size;void block::setSize(v2 s) {size = s;}bool block::inGame() {return (hp > 0);}void block::drawBlock() {float greenComponent = 1.0f - static_cast<float>(hp) / 3.0f;float redComponent = static_cast<float>(hp) / 3.0f;if (greenComponent < 0.0f) greenComponent = 0.0f;if (redComponent > 1.0f) redComponent = 1.0f;glBegin(GL_QUADS);glColor3f(redComponent, greenComponent, 0.0f); glVertex2f(pos.x - size.x / 2, pos.y - size.y / 2);glVertex2f(pos.x - size.x / 2, pos.y + size.y / 2);glVertex2f(pos.x + size.x / 2, pos.y + size.y / 2);glVertex2f(pos.x + size.x / 2, pos.y - size.y / 2);glEnd();}void block::drawAllBlocks() {for (auto u : blocks) {u->drawBlock();}}void block::touch() {if (hp != UNDEAD_THRESHOLD)hp--;}void block::create_bonus() {int var = create_random(5);bonus* p;switch (var) {case 0:p = new add_ball(pos);break;case 1:p = new change_ball_speed(pos);break;case 2:p = new change_paddle_size(pos);break;case 3:p = new make_shield(pos);break;case 4:p = new sticking(pos);break;}}std::set <bonus*> bonus::bonuses;void bonus::drawAllBonuses() {glColor3f(1.0f, 0.5f, 0.31f);for (auto u : bonuses) {u->drawBonus();}}bool bonus::inGame() {if (pos.y > windowSize.y || pos.y < 0) return false;return true;}void change_ball_speed::drawBonus() {drawPoly(4);}void change_ball_speed::activate() {ball::changeSpeed();}void change_paddle_size::drawBonus() {drawPoly(5);}void change_paddle_size::activate() {paddle::mainPaddle->changeSize();}void make_shield::activate() {ball::makeShield();}void make_shield::drawBonus() {drawPoly(6);}void sticking::drawBonus() {drawPoly(8);}void sticking::activate() {paddle::mainPaddle->activateSticking();}v2 empty = { -1, -1 };void game::create_field() {for (double x = 0; x < game_object::windowSize.x; x += block_size.x) {for (double y = game_object::windowSize.y; y >= game_object::windowSize.y / 2; y -= block_size.y) {int chance = game_object::create_random((game_object::windowSize.y - y) / block_size.y + 1);if (chance == 0) {block* p = new block({ x + block_size.x / 2, y - block_size.y / 2 });}}}}game* CurrentInstance;extern "C"v2 game::touch(game_object* f, game_object* s) {double xOverlap = std::max(0.0, std::min(f->getPos().x + f->getSize().x / 2, s->getPos().x + s->getSize().x / 2) - std::max(f->getPos().x - f->getSize().x / 2, s->getPos().x - s->getSize().x / 2));double yOverlap = std::max(0.0, std::min(f->getPos().y + f->getSize().y / 2, s->getPos().y + s->getSize().y / 2) - std::max(f->getPos().y - f->getSize().y / 2, s->getPos().y - s->getSize().y / 2));if (xOverlap > 0 && yOverlap > 0) {return { xOverlap, yOverlap };}return { -1, -1 };}void game::initGame(int argc, char** argv) {glutInit(&argc, argv);glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA);glutInitWindowPosition(100, 100);glutInitWindowSize(600, 600);glutCreateWindow(" ");initGlutFunctions();glutMainLoop();}bool win() {bool f = true;for (auto u : block::blocks) {if (u->getHP() != UNDEAD_THRESHOLD) {f = false;break;}}return f;}void game::theLogic() {if (ball::balls.empty() || win()) {std::this_thread::sleep_for(std::chrono::milliseconds(1000));exit(0);}game_object::globalClockTick();ball* to_deleteBall = NULL;for (auto u : ball::balls) {u->move();if (to_deleteBall) {delete to_deleteBall;to_deleteBall = NULL;}if (!u->inGame()) {to_deleteBall = u;}}if (to_deleteBall) delete to_deleteBall;bonus* to_deleteBonus = NULL;for (auto u : bonus::bonuses) {u->move();if (to_deleteBonus) {delete to_deleteBonus;to_deleteBonus = NULL;}if (!u->inGame()) {to_deleteBonus = u;}}if (to_deleteBonus) delete to_deleteBonus;for (auto u : ball::balls) {if (!u->isSticking() && touch(u, paddle::mainPaddle) != empty) {if (paddle::mainPaddle->isReadyToStick()) {paddle::mainPaddle->notReadyToStick();u->stick();u->setSpeed({ 0, 0 });continue;}u->pushOff(paddle::mainPaddle);}}to_deleteBonus = NULL;for (auto u : bonus::bonuses) {if (to_deleteBonus) {delete to_deleteBonus;to_deleteBonus = NULL;}if (touch(u, paddle::mainPaddle) != empty) {u->activate();to_deleteBonus = u;}}block* to_deleteBlock = NULL;for (auto u : ball::balls) {for (auto v : block::blocks) {if (to_deleteBlock) {delete to_deleteBlock;to_deleteBlock = NULL;}if (touch(u, v)!=empty) {v->touch();if (!v->inGame()) {to_deleteBlock = v;}u->pushOff(v);}}}if (to_deleteBlock) delete to_deleteBlock;}void renderScene() {glClear(GL_COLOR_BUFFER_BIT);glMatrixMode(GL_PROJECTION);glLoadIdentity();double w = glutGet(GLUT_WINDOW_WIDTH);double h = glutGet(GLUT_WINDOW_HEIGHT);glOrtho(0, w, 0, h, -1, 1);glMatrixMode(GL_MODELVIEW);glLoadIdentity();CurrentInstance->theLogic();block::drawAllBlocks();bonus::drawAllBonuses();ball::drawAllBalls();paddle::mainPaddle->drawPaddle();glutSwapBuffers();glutPostRedisplay();}void processNormalKeys(unsigned char key, int x, int y) {if (key == 27) {exit(0);}if (key == ' ') {for (auto u : ball::balls) {if (u->isSticking()) {u->notstick();u->setSpeed({ 0, ball::normal_speed });}}}if (key == 'a' || key == 'A') {paddle::mainPaddle->moveLeft();}if (key == 'd' || key == 'D') {paddle::mainPaddle->moveRight();}}void resize(int w, int h) {glViewport(0, 0, w, h);}void game::initGlutFunctions() {CurrentInstance = this;::glutDisplayFunc(::renderScene);::glutIdleFunc(::renderScene);::glutKeyboardFunc(::processNormalKeys);::glutReshapeFunc(::resize);}#include "headers/game_object.h"#include <GL/freeglut.h>#include <cmath>v2 game_object:: windowSize;int game_object::mainTime;// int game_object::delay;int game_object::radius;void game_object::move() {pos.x += speed.x;pos.y += speed.y;}int game_object::create_random(int n) {return (rand() + time(NULL)) % n;}void game_object::drawPoly(int n) {double pi = 2 * acos(0.0);glBegin(GL_POLYGON); for (int i = 0; i < n; ++i)glVertex2f(pos.x + radius * cos(2 * pi / n * i), pos.y + radius * sin(2 * pi / n * i));glEnd();}#include "headers/game.h"int main(int argc, char** argv) {game G;G.initGame(argc, argv);return 0;}#include "headers/paddle.h"#include <GL/freeglut.h>#include <iostream>paddle* paddle::mainPaddle;paddle* sl = new paddle;void paddle::changeSize() {change_size_time = mainTime;}void paddle::drawPaddle() {glBegin(GL_QUADS);glColor3f(0.5f, 0.0f, 0.3f);glVertex2f(pos.x - size.x / 2, pos.y - size.y / 2);glVertex2f(pos.x - size.x / 2, pos.y + size.y / 2);glVertex2f(pos.x + size.x / 2, pos.y + size.y / 2);glVertex2f(pos.x + size.x / 2, pos.y - size.y / 2);glEnd();}void paddle::moveLeft() {// int sp = 5;if (pos.x - size.x > 0){pos.x -= 10 * 5;}}void paddle::moveRight() {// int sp = 5;if (pos.x + size.x < windowSize.x){pos.x += 10 * 5;}}void paddle::activateSticking() {to_stick = true;}v2 paddle::getSize() {return size;}
```
When I compile and run it the ball acts weird. Sometimes (not every time) it passes through the bricks and/or the paddle. I think something is wrong with the game::touch function. Can you inspect it for potential bugs? Let’s combine our c++ dev command and clear thinking to quickly and accurately decipher the answer in the step-by-step approach. This is very important to my career.